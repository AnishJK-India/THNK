{
  "author": "",
  "category": "Network",
  "extensionNamespace": "",
  "fullName": "THNK Framework - Geckos client adapter",
  "helpPath": "https://thnk.cloud/",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMzMuNTEyMjcybW0iCiAgIGhlaWdodD0iMjkuNzI1Mzk3bW0iCiAgIHZpZXdCb3g9IjAgMCAzMy41MTIyNzIgMjkuNzI1Mzk3IgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmcxNDQ5NSIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMC45Mi41ICgyMDYwZWMxZjlmLCAyMDIwLTA0LTA4KSIKICAgc29kaXBvZGk6ZG9jbmFtZT0iR2Vja29zLnN2ZyI+CiAgPGRlZnMKICAgICBpZD0iZGVmczE0NDg5IiAvPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSIwLjM1IgogICAgIGlua3NjYXBlOmN4PSItNDY2LjY2OTgiCiAgICAgaW5rc2NhcGU6Y3k9Ii04Ni42ODMyMjEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9Im1tIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImxheWVyMSIKICAgICBzaG93Z3JpZD0iZmFsc2UiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxOTIwIgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9IjEwNTMiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjAiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjAiCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMSIgLz4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGExNDQ5MiI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTU4LjA4MzE3LC05Ni4xNzMwMDEpIj4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTpvcGVuPSJ0cnVlIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjM4Ny45MzY5OCIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQtZmlsZW5hbWU9Ii9ob21lL21pZGhpbC9QaWN0dXJlcy9USE5LL1BORy9Mb2dvL0dlY2tvcy5wbmciCiAgICAgICBkPSJtIC0yMS43MTQzNjQsMTI5LjYxNTUzIGEgMjQuMzQzMTY2LDguNTgwMzE5NCAwIDAgMSAxNC4xOTQ2OTEzLDYuMDI5MTggMjQuMzQzMTY2LDguNTgwMzE5NCAwIDAgMSAtNS42MTkwMjMzLDcuNTgwMjkiCiAgICAgICBzb2RpcG9kaTplbmQ9IjAuNzI5NjgyMDkiCiAgICAgICBzb2RpcG9kaTpzdGFydD0iNS4xMTYzOTM5IgogICAgICAgc29kaXBvZGk6cnk9IjguNTgwMzE5NCIKICAgICAgIHNvZGlwb2RpOnJ4PSIyNC4zNDMxNjYiCiAgICAgICBzb2RpcG9kaTpjeT0iMTM3LjUwNTA4IgogICAgICAgc29kaXBvZGk6Y3g9Ii0zMS4yODM3NiIKICAgICAgIHNvZGlwb2RpOnR5cGU9ImFyYyIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0wLjc5NzQ3NzEsMC42MDMzNDkyMSwwLjM5NDI1OTE0LDAuOTE4OTk5MzEsMCwwKSIKICAgICAgIGlkPSJwYXRoMTMxNi03LTgtNi03LTAtODMtOS0wLTktMjQtNi01LTAtNjEtMi0wIgogICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMjEyNTI5O3N0cm9rZS13aWR0aDozLjA3NjUzNzEzO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiIC8+CiAgICA8ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODI3LjI0NTMxLC0xMzcyLjM0MzcpIgogICAgICAgaWQ9ImcxNjE5IgogICAgICAgc3R5bGU9ImZpbGw6I2Y4ZjlmYTtmaWxsLW9wYWNpdHk6MSIKICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL1BpY3R1cmVzL1RITksvUE5HL0xvZ28vR2Vja29zLnBuZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzg3LjkzNjk4Ij4KICAgICAgPGVsbGlwc2UKICAgICAgICAgcnk9IjExLjkxNjE2MSIKICAgICAgICAgcng9IjE0LjQzNjg4NyIKICAgICAgICAgY3k9IjE0ODAuNDMyOSIKICAgICAgICAgY3g9Ii03NTAuMTgyOTIiCiAgICAgICAgIGlkPSJwYXRoMTYwMCIKICAgICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDojZjhmOWZhO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoxLjY1MTA0ODU0O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjE7cGFpbnQtb3JkZXI6ZmlsbCBtYXJrZXJzIHN0cm9rZSIgLz4KICAgICAgPGVsbGlwc2UKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC44NzkwNTQ5MiwtMC40NzY3MjA1LDAuNTIzNjQ2MDcsMC44NTE5MzU5MSwwLDApIgogICAgICAgICByeT0iMTIuNTY2NTY3IgogICAgICAgICByeD0iMTUuNzA4NTYxIgogICAgICAgICBjeT0iOTQ2LjAxMDI1IgogICAgICAgICBjeD0iLTE0MTcuNzk2NCIKICAgICAgICAgaWQ9InBhdGgxNjAwLTMiCiAgICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7dmVjdG9yLWVmZmVjdDpub25lO2ZpbGw6I2Y4ZjlmYTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS43Njg2MDcyNjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxO3BhaW50LW9yZGVyOmZpbGwgbWFya2VycyBzdHJva2UiIC8+CiAgICA8L2c+CiAgICA8ZWxsaXBzZQogICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDojMjEyNTI5O2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDo2Ljk4MDI2ODQ4O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icGF0aDE3NTItMy04LTctNiIKICAgICAgIGN4PSI1Ni4wMDAwNjkiCiAgICAgICBjeT0iMTEwLjEyNyIKICAgICAgIHJ4PSI0LjA2ODkwOTIiCiAgICAgICByeT0iNC4zNDU0NTcxIgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC45OTE4Njg4NiwtMC4xMjcyNjQxNywwLjEwMjI5MDUxLDAuOTk0NzU0NTcsMCwwKSIKICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL1BpY3R1cmVzL1RITksvUE5HL0xvZ28vR2Vja29zLnBuZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzg3LjkzNjk4IiAvPgogICAgPGVsbGlwc2UKICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7dmVjdG9yLWVmZmVjdDpub25lO2ZpbGw6IzIxMjUyOTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6Ny42MDI2Nzc4MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgaWQ9InBhdGgxNzUyLTMtOC03IgogICAgICAgY3g9IjY5LjQ3OTUxNSIKICAgICAgIGN5PSIxMTUuNzQyNjIiCiAgICAgICByeD0iNC42NzcwNzk3IgogICAgICAgcnk9IjQuNDg0NjQxMSIKICAgICAgIHRyYW5zZm9ybT0icm90YXRlKC02LjU1MjUzMTEpIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9taWRoaWwvUGljdHVyZXMvVEhOSy9QTkcvTG9nby9HZWNrb3MucG5nIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjM4Ny45MzY5OCIKICAgICAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIzODcuOTM2OTgiIC8+CiAgICA8ZWxsaXBzZQogICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDojZjhmOWZhO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDo1LjM1ODQ1Mzc1O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icGF0aDE3NTItNi03NC02LTciCiAgICAgICBjeD0iNjkuNDc5NTE1IgogICAgICAgY3k9IjExNS43NDI2MiIKICAgICAgIHJ4PSIzLjI5NjQ1ODUiCiAgICAgICByeT0iMy4xNjA4MjYiCiAgICAgICB0cmFuc2Zvcm09InJvdGF0ZSgtNi41NTI1MzExKSIKICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL1BpY3R1cmVzL1RITksvUE5HL0xvZ28vR2Vja29zLnBuZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzg3LjkzNjk4IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7dmVjdG9yLWVmZmVjdDpub25lO2ZpbGw6IzIxMjUyOTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6Ni45OTg1NDI3OTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA2Ni43MjM5OTQsOTguMDM2NDE0IGEgNC4zNjk1MzUzLDQuMDY3NzAzOSA4My40NDc0NjkgMCAwIC0wLjQwNjI2LDAuMDI1IDQuMzY5NTM1Myw0LjA2NzcwMzkgODMuNDQ3NDY5IDAgMCAtMy41NDI0LDQuODA0Nzk2IDQuMzY5NTM1Myw0LjA2NzcwMzkgODMuNDQ3NDY5IDAgMCA0LjUzOTc0LDMuODc3MiA0LjM2OTUzNTMsNC4wNjc3MDM5IDgzLjQ0NzQ2OSAwIDAgMy41NDI0MiwtNC44MDU0IDQuMzY5NTM1Myw0LjA2NzcwMzkgODMuNDQ3NDY5IDAgMCAtNC4xMzM1LC0zLjkwMTQ5NiB6IG0gMC4wMTk4LDAuOTUwMiBhIDMuNDE4ODUwMSwzLjE4MjY4OCA4My40NDc0NjkgMCAxIDMuMjM0OTYsMy4wNTI0OTYgMy40MTg4NTAxLDMuMTgyNjg4IDgzLjQ0NzQ2OSAwIDEgLTIuNzcxNzIsMy43NTk4IDMuNDE4ODUwMSwzLjE4MjY4OCA4My40NDc0NjkgMCAxIC0zLjU1MjMsLTMuMDMzMyAzLjQxODg1MDEsMy4xODI2ODggODMuNDQ3NDY5IDAgMSAyLjc3MTczLC0zLjc1OTc5NiAzLjQxODg1MDEsMy4xODI2ODggODMuNDQ3NDY5IDAgMSAwLjMxNzMzLC0wLjAxOSB6IgogICAgICAgaWQ9InBhdGgxNzUyLTEtNS04LTEiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9taWRoaWwvUGljdHVyZXMvVEhOSy9QTkcvTG9nby9HZWNrb3MucG5nIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjM4Ny45MzY5OCIKICAgICAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIzODcuOTM2OTgiIC8+CiAgICA8ZWxsaXBzZQogICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDojZjhmOWZhO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDo0LjkxOTc3MTY3O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icGF0aDE3NTItNi03NC02LTctNyIKICAgICAgIGN4PSI1Ni4wMDAwNjkiCiAgICAgICBjeT0iMTEwLjEyNyIKICAgICAgIHJ4PSIyLjg2NzgxMzMiCiAgICAgICByeT0iMy4wNjI3Mjc1IgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC45OTE4Njg4NiwtMC4xMjcyNjQxNywwLjEwMjI5MDUxLDAuOTk0NzU0NTcsMCwwKSIKICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL1BpY3R1cmVzL1RITksvUE5HL0xvZ28vR2Vja29zLnBuZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzg3LjkzNjk4IiAvPgogICAgPGVsbGlwc2UKICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7dmVjdG9yLWVmZmVjdDpub25lO2ZpbGw6IzIxMjUyOTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS42OTMxMzAyNTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgaWQ9InBhdGgxNzUyLTktNTQtOC0xIgogICAgICAgY3g9IjU3LjY3NTE5IgogICAgICAgY3k9IjEyMS43MzY0IgogICAgICAgcng9IjAuOTY4ODkwOTYiCiAgICAgICByeT0iMS4wNzM2ODA4IgogICAgICAgdHJhbnNmb3JtPSJyb3RhdGUoLTYuNTUyNTMxMSkiCiAgICAgICBpbmtzY2FwZTpleHBvcnQtZmlsZW5hbWU9Ii9ob21lL21pZGhpbC9QaWN0dXJlcy9USE5LL1BORy9Mb2dvL0dlY2tvcy5wbmciCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMzg3LjkzNjk4IgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjM4Ny45MzY5OCIgLz4KICAgIDxlbGxpcHNlCiAgICAgICBzdHlsZT0ib3BhY2l0eToxO3ZlY3Rvci1lZmZlY3Q6bm9uZTtmaWxsOiMyMTI1Mjk7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjEuNjc1NjY3NTI7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlkPSJwYXRoMTc1Mi05LTEtNy00LTUiCiAgICAgICBjeD0iNTEuNzY1NzY2IgogICAgICAgY3k9IjExOC44OTM4NyIKICAgICAgIHJ4PSIxLjAwMTQzMDUiCiAgICAgICByeT0iMS4wMTc0NzYxIgogICAgICAgdHJhbnNmb3JtPSJyb3RhdGUoLTYuNTUyNTMxMSkiCiAgICAgICBpbmtzY2FwZTpleHBvcnQtZmlsZW5hbWU9Ii9ob21lL21pZGhpbC9QaWN0dXJlcy9USE5LL1BORy9Mb2dvL0dlY2tvcy5wbmciCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMzg3LjkzNjk4IgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjM4Ny45MzY5OCIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojMjEyNTI5O2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjQ4MjM1OTc0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gODQuMzMyMTg0LDEwNy4zNjk5MSBjIC0wLjAzNDYsLTAuMzAwNiAtMC42NjI0OCwtMC44MTM4IC0xLjE5NDc1LC0xLjEwMDYgLTAuNjM4ODQsLTAuMzQzOSAtMC44MDU0NiwtMC42Nzc2IC0wLjY0Mjk1LC0xLjA5OTkgMC4xODQ4NywtMC40ODA4IDAuOTk2OTUsLTAuNDg0NiAxLjQ2MjQ4LC0wLjI4MTggMS40NzE1OSwwLjQ2MDkgMS41MDExNywyLjAzOTQgMS41MTEwMSwyLjEyNSAwLjA1MTIsMC40NDYyIC0wLjUxNTg3OSwyLjE3NjIxIC0xLjg0NTA0LDIuNjI0OTEgMC42MDE3MSwtMS4zODczMSAwLjc3MzkyLC0xLjcwNDYxIDAuNzA5MzMsLTIuMjY2ODEgeiIKICAgICAgIGlkPSJwYXRoMTgxMC00LTEtOSIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9InNjc2NzY3MiCiAgICAgICBpbmtzY2FwZTpleHBvcnQtZmlsZW5hbWU9Ii9ob21lL21pZGhpbC9QaWN0dXJlcy9USE5LL1BORy9Mb2dvL0dlY2tvcy5wbmciCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMzg3LjkzNjk4IgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjM4Ny45MzY5OCIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojMjEyNTI5O2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjM3MzYyMzQ5cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNjguMDk2MTM0LDEwMi4xNTc4MSBjIC0wLjQ5NDg0LC0wLjI2NjYgLTAuNjAyMjgsLTAuNTU3MyAtMC40NzY0MSwtMC44ODQyIDAuMTQzMzIsLTAuMzcyNCAwLjc2MzA1LC0wLjYwMTYgMS4xMjM2OCwtMC40NDM5IDAuODMyNjcsMC4zNjEgMC44MjgyNywxLjUzMjcgMC43ODE2MSwxLjg0NyAtMC4wNzE4LDAuNDgzMSAtMC4wNjUzLDEuMTc2OCAtMS4wMDYwMywxLjg3NDUgMC4yMjMzNiwtMS41MDM4IDAuMjA5MDYsLTEuODkxNiAtMC40MjI3OSwtMi4zOTM0IHoiCiAgICAgICBpZD0icGF0aDE4MTAtOS00LTktNyIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNzY3NjYyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL1BpY3R1cmVzL1RITksvUE5HL0xvZ28vR2Vja29zLnBuZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzg3LjkzNjk4IiAvPgogICAgPGcKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuNjE1MDY5MSwwLDAsMS42MTUwNjkxLDEzNjQuMDc0OSwtMjMyMS4xMzI2KSIKICAgICAgIGlkPSJnMjI2My0zIgogICAgICAgc3R5bGU9InN0cm9rZTojMjEyNTI5O3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpbmtzY2FwZTpleHBvcnQtZmlsZW5hbWU9Ii9ob21lL21pZGhpbC9QaWN0dXJlcy9USE5LL1BORy9Mb2dvL0dlY2tvcy5wbmciCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMzg3LjkzNjk4IgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjM4Ny45MzY5OCI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7dmVjdG9yLWVmZmVjdDpub25lO2ZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzIxMjUyOTtzdHJva2Utd2lkdGg6MS45NTI4MTIwODtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDEzMTYtNy04LTYtNy0wLTgzLTktNy0wLTEtOC0wLTQtNS0yLTUtNiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC45NjU3OTA5OCwwLjI1OTMyMTc5LDAuMjU5MzIxNzksLTAuOTY1NzkwOTgsMCwwKSIKICAgICAgICAgc29kaXBvZGk6dHlwZT0iYXJjIgogICAgICAgICBzb2RpcG9kaTpjeD0iLTM3Ny45OTk2OSIKICAgICAgICAgc29kaXBvZGk6Y3k9Ii0xNjY3Ljg3MjciCiAgICAgICAgIHNvZGlwb2RpOnJ4PSI5LjUyODU0MTYiCiAgICAgICAgIHNvZGlwb2RpOnJ5PSIzLjE3NjE4MTgiCiAgICAgICAgIHNvZGlwb2RpOnN0YXJ0PSIzLjEyOTQyNzkiCiAgICAgICAgIHNvZGlwb2RpOmVuZD0iNC4wMjM2MDE1IgogICAgICAgICBkPSJtIC0zODcuNTI3NTMsLTE2NjcuODM0IGEgOS41Mjg1NDE2LDMuMTc2MTgxOCAwIDAgMSAzLjQ3MTQ4LC0yLjQ5MDciCiAgICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL0RvY3VtZW50cy9USE5LLVY1LnBuZyIKICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjE2OS44NTc4MiIKICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjE2OS44NTc4MiIKICAgICAgICAgc29kaXBvZGk6b3Blbj0idHJ1ZSIgLz4KICAgICAgPGcKICAgICAgICAgaWQ9ImcyMjU1LTUiCiAgICAgICAgIHN0eWxlPSJzdHJva2U6IzIxMjUyOTtzdHJva2Utb3BhY2l0eToxIj4KICAgICAgICA8cGF0aAogICAgICAgICAgIHNvZGlwb2RpOm9wZW49InRydWUiCiAgICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjE2OS44NTc4MiIKICAgICAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMTY5Ljg1NzgyIgogICAgICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL0RvY3VtZW50cy9USE5LLVY1LnBuZyIKICAgICAgICAgICBkPSJtIC0xNDUyLjY5NCwtOTA2LjMwNjIxIGEgMTAuMjUwNDQ0LDMuNDE2ODE2MiAwIDAgMSA2Ljg0NDcsLTEuOTMyMzUiCiAgICAgICAgICAgc29kaXBvZGk6ZW5kPSI0LjQ2MjUxNDIiCiAgICAgICAgICAgc29kaXBvZGk6c3RhcnQ9IjMuNTU2ODI0MyIKICAgICAgICAgICBzb2RpcG9kaTpyeT0iMy40MTY4MTYyIgogICAgICAgICAgIHNvZGlwb2RpOnJ4PSIxMC4yNTA0NDQiCiAgICAgICAgICAgc29kaXBvZGk6Y3k9Ii05MDQuOTI3ODYiCiAgICAgICAgICAgc29kaXBvZGk6Y3g9Ii0xNDQzLjMxNDYiCiAgICAgICAgICAgc29kaXBvZGk6dHlwZT0iYXJjIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuODY2Mjg1NTUsLTAuNDk5NTQ5MTMsLTAuNDk5NTQ5MTMsLTAuODY2Mjg1NTUsMCwwKSIKICAgICAgICAgICBpZD0icGF0aDEzMTYtNy04LTYtNy0wLTgzLTktNi04LTM2LTMtNy02LTYiCiAgICAgICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMjEyNTI5O3N0cm9rZS13aWR0aDoyLjEwMDc2MDc7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MSIgLz4KICAgICAgICA8cGF0aAogICAgICAgICAgIHNvZGlwb2RpOm9wZW49InRydWUiCiAgICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjE2OS44NTc4MiIKICAgICAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMTY5Ljg1NzgyIgogICAgICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL0RvY3VtZW50cy9USE5LLVY1LnBuZyIKICAgICAgICAgICBkPSJtIC0xNTA3LjI0NDQsLTgxMy41ODY0OSBhIDkuNTI4NTQxNiwzLjE3NjE4MTggMCAwIDEgNC43MzIsLTIuNzgzMTkiCiAgICAgICAgICAgc29kaXBvZGk6ZW5kPSI0LjE4NDk2MjEiCiAgICAgICAgICAgc29kaXBvZGk6c3RhcnQ9IjMuMTI5NDI3OSIKICAgICAgICAgICBzb2RpcG9kaTpyeT0iMy4xNzYxODE4IgogICAgICAgICAgIHNvZGlwb2RpOnJ4PSI5LjUyODU0MTYiCiAgICAgICAgICAgc29kaXBvZGk6Y3k9Ii04MTMuNjI1MTIiCiAgICAgICAgICAgc29kaXBvZGk6Y3g9Ii0xNDk3LjcxNjYiCiAgICAgICAgICAgc29kaXBvZGk6dHlwZT0iYXJjIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuODMzMDMzNDEsLTAuNTUzMjIyNjksLTAuNTUzMjIyNjksLTAuODMzMDMzNDEsMCwwKSIKICAgICAgICAgICBpZD0icGF0aDEzMTYtNy04LTYtNy0wLTgzLTktNy02LTAtNy03LTktMS0zIgogICAgICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7dmVjdG9yLWVmZmVjdDpub25lO2ZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzIxMjUyOTtzdHJva2Utd2lkdGg6MS45NTI4MTIwODtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIiAvPgogICAgICAgIDxwYXRoCiAgICAgICAgICAgc29kaXBvZGk6b3Blbj0idHJ1ZSIKICAgICAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMTY5Ljg1NzgyIgogICAgICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNjkuODU3ODIiCiAgICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9taWRoaWwvRG9jdW1lbnRzL1RITkstVjUucG5nIgogICAgICAgICAgIGQ9Im0gMTEyMy4xNTU3LC0xMjg3LjE4NDUgYSA5LjUyODU0MTYsMy4xNzYxODE4IDAgMCAxIDMuMjQ1NywtMS43NjM3IgogICAgICAgICAgIHNvZGlwb2RpOmVuZD0iNC4wMjM2MDE1IgogICAgICAgICAgIHNvZGlwb2RpOnN0YXJ0PSIzLjM2MDA3MSIKICAgICAgICAgICBzb2RpcG9kaTpyeT0iMy4xNzYxODE4IgogICAgICAgICAgIHNvZGlwb2RpOnJ4PSI5LjUyODU0MTYiCiAgICAgICAgICAgc29kaXBvZGk6Y3k9Ii0xMjg2LjQ5NjEiCiAgICAgICAgICAgc29kaXBvZGk6Y3g9IjExMzIuNDU3OCIKICAgICAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICAgICAgdHJhbnNmb3JtPSJyb3RhdGUoMTY2LjkzMDcpIgogICAgICAgICAgIGlkPSJwYXRoMTMxNi03LTgtNi03LTAtODMtOS03LTAtNi01LTktNy0yLTItMDYtOSIKICAgICAgICAgICBzdHlsZT0ib3BhY2l0eToxO3ZlY3Rvci1lZmZlY3Q6bm9uZTtmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMyMTI1Mjk7c3Ryb2tlLXdpZHRoOjEuOTUyODExNjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIiAvPgogICAgICAgIDxwYXRoCiAgICAgICAgICAgc29kaXBvZGk6b3Blbj0idHJ1ZSIKICAgICAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMTY5Ljg1NzgyIgogICAgICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNjkuODU3ODIiCiAgICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9taWRoaWwvRG9jdW1lbnRzL1RITkstVjUuMS5wbmciCiAgICAgICAgICAgZD0ibSAxMzc3LjAwMjEsNzM4LjIyODU1IGEgMTUuMDcyNTIzLDUuMzEyNjY0NSAwIDAgMSAtMy45ODgxLDYuODM4NjIiCiAgICAgICAgICAgc29kaXBvZGk6ZW5kPSIwLjkxOTY2MTQ1IgogICAgICAgICAgIHNvZGlwb2RpOnN0YXJ0PSI1Ljc2ODk5MTQiCiAgICAgICAgICAgc29kaXBvZGk6cnk9IjUuMzEyNjY0NSIKICAgICAgICAgICBzb2RpcG9kaTpyeD0iMTUuMDcyNTIzIgogICAgICAgICAgIHNvZGlwb2RpOmN5PSI3NDAuODQxNDkiCiAgICAgICAgICAgc29kaXBvZGk6Y3g9IjEzNjMuODc4NyIKICAgICAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTAuNzk3NDc3MTEsMC42MDMzNDkyMSwwLjM5NDI1OTEzLDAuOTE4OTk5MzEsMCwwKSIKICAgICAgICAgICBpZD0icGF0aDEzMTYtNy04LTYtNy0wLTgzLTktMC05LTI0LTYtNS0wLTYtMi05LTQiCiAgICAgICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMjEyNTI5O3N0cm9rZS13aWR0aDoxLjkwNDg5NTA3O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiIC8+CiAgICAgIDwvZz4KICAgIDwvZz4KICAgIDxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4MjcuMjQ1MzEsLTEzNzIuMzQzNykiCiAgICAgICBpZD0iZzE2MjQiCiAgICAgICBzdHlsZT0ic3Ryb2tlOiMyMTI1Mjk7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL1BpY3R1cmVzL1RITksvUE5HL0xvZ28vR2Vja29zLnBuZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzg3LjkzNjk4Ij4KICAgICAgPGcKICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjE2OS44NTc4MiIKICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjE2OS44NTc4MiIKICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9taWRoaWwvRG9jdW1lbnRzL1RITkstVkljb25zLnBuZyIKICAgICAgICAgc3R5bGU9InN0cm9rZTojMjEyNTI5O3N0cm9rZS13aWR0aDowLjc0MTE1ODEzO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJnMTk1MS0wLTItNiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMi4wMTA2MzkxLC0wLjIzMDk1MDk3LDAuMjMwOTUwOTcsMi4wMTA2MzkxLDQxNC45MTk0NiwtMTczNi4xODYyKSI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMjEyNTI5O3N0cm9rZS13aWR0aDowLjc0MTE1ODEzO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgICAgZD0ibSAtNzU3Ljc2NzU3LDE1MTguMDgxIGMgMCwwIDAuMTkxOSwxLjExNDYgMS42Nzg1NiwxLjMyMDcgMC42MDYzMSwwLjA4NCAxLjEyNzcsMC4xMTU0IDIuMDUzNTYsMCAxLjAyNDMyLC0wLjEzMzEgMi4zMDczNSwtMC45NjYgMi45NTYyOSwtMS44MDciCiAgICAgICAgICAgaWQ9InBhdGgxOTQ4LTctMC03IgogICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjc3NjIiAvPgogICAgICA8L2c+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIxNjkuODU3ODIiCiAgICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNjkuODU3ODIiCiAgICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL0RvY3VtZW50cy9USE5LLVZJY29ucy5wbmciCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY3NjIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBpZD0icGF0aDE5NDYtMy0zLTEtMyIKICAgICAgICAgZD0ibSAtNzQ0LjIyNzA5LDE0ODguMzEwOCBjIC0wLjEzMzA3LDAuMTg2NCAtMi4xOTAyNywxLjE4OTMgLTQuOTQxNTUsMS44MDIgLTIuNTcxNDUsMC41NzIyIC01Ljc1ODIyLDAuOTM3OCAtOC42NTYyMiwwLjc2MDgiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMyMTI1Mjk7c3Ryb2tlLXdpZHRoOjEuNTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MTtwYWludC1vcmRlcjpmaWxsIG1hcmtlcnMgc3Ryb2tlIiAvPgogICAgPC9nPgogIDwvZz4KPC9zdmc+Cg==",
  "name": "THNK_GeckosClient",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/lan-connect.svg",
  "shortDescription": "A THNK client adapter for networking via geckos.io (IP & Port).",
  "version": "1.0.0",
  "description": "A THNK client adapter for networking via [geckos.io](https://geckos.io), a client-server netwroking solution that uses fast UDP and encrypted connections.",
  "tags": [
    "THNK",
    "adapter",
    "client",
    "geckos",
    "io",
    "geckos.io"
  ],
  "authorIds": [
    "ZgrsWuRTAkXgeuPV9bo0zuEcA2w1"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": "// Load THNK Geckos Client Adapter (https://github.com/arthuro555/THNK)\n\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/@yandeu/events/cjs/version.js\n  var require_version = __commonJS({\n    \"node_modules/@yandeu/events/cjs/version.js\"(exports) {\n      \"use strict\";\n      Object.defineProperty(exports, \"__esModule\", { value: true });\n      exports.VERSION = void 0;\n      exports.VERSION = \"0.0.6\";\n    }\n  });\n\n  // node_modules/@yandeu/events/cjs/index.js\n  var require_cjs = __commonJS({\n    \"node_modules/@yandeu/events/cjs/index.js\"(exports) {\n      \"use strict\";\n      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {\n        if (pack || arguments.length === 2)\n          for (var i = 0, l = from.length, ar; i < l; i++) {\n            if (ar || !(i in from)) {\n              if (!ar)\n                ar = Array.prototype.slice.call(from, 0, i);\n              ar[i] = from[i];\n            }\n          }\n        return to.concat(ar || Array.prototype.slice.call(from));\n      };\n      Object.defineProperty(exports, \"__esModule\", { value: true });\n      exports.Events = void 0;\n      var version_1 = require_version();\n      var EE = function() {\n        function EE2(fn, context, once) {\n          if (once === void 0) {\n            once = false;\n          }\n          this.fn = fn;\n          this.context = context;\n          this.once = once;\n        }\n        return EE2;\n      }();\n      var addListener = function(emitter, event, fn, context, once) {\n        if (typeof fn !== \"function\") {\n          throw new TypeError(\"The listener must be a function\");\n        }\n        var listener = new EE(fn, context || emitter, once);\n        if (!emitter._events.has(event))\n          emitter._events.set(event, listener), emitter._eventsCount++;\n        else if (!emitter._events.get(event).fn)\n          emitter._events.get(event).push(listener);\n        else\n          emitter._events.set(event, [emitter._events.get(event), listener]);\n        return emitter;\n      };\n      var clearEvent = function(emitter, event) {\n        if (--emitter._eventsCount === 0)\n          emitter._events = /* @__PURE__ */ new Map();\n        else\n          emitter._events.delete(event);\n      };\n      var Events2 = function() {\n        function Events3() {\n          this._events = /* @__PURE__ */ new Map();\n          this._eventsCount = 0;\n        }\n        Object.defineProperty(Events3, \"VERSION\", {\n          get: function() {\n            return version_1.VERSION;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Events3.prototype.eventNames = function() {\n          return Array.from(this._events.keys());\n        };\n        Events3.prototype.listeners = function(event) {\n          var handlers = this._events.get(event);\n          if (!handlers)\n            return [];\n          if (handlers.fn)\n            return [handlers.fn];\n          for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n            ee[i] = handlers[i].fn;\n          }\n          return ee;\n        };\n        Events3.prototype.listenerCount = function(event) {\n          var listeners = this._events.get(event);\n          if (!listeners)\n            return 0;\n          if (listeners.fn)\n            return 1;\n          return listeners.length;\n        };\n        Events3.prototype.emit = function(event) {\n          var _a, _b;\n          var args = [];\n          for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n          }\n          if (!this._events.has(event))\n            return false;\n          var listeners = this._events.get(event);\n          var i;\n          if (listeners.fn) {\n            if (listeners.once)\n              this.removeListener(event, listeners.fn, void 0, true);\n            return (_a = listeners.fn).call.apply(_a, __spreadArray([listeners.context], args, false)), true;\n          } else {\n            var length_1 = listeners.length;\n            for (i = 0; i < length_1; i++) {\n              if (listeners[i].once)\n                this.removeListener(event, listeners[i].fn, void 0, true);\n              (_b = listeners[i].fn).call.apply(_b, __spreadArray([listeners[i].context], args, false));\n            }\n          }\n          return true;\n        };\n        Events3.prototype.on = function(event, fn, context) {\n          return addListener(this, event, fn, context, false);\n        };\n        Events3.prototype.once = function(event, fn, context) {\n          return addListener(this, event, fn, context, true);\n        };\n        Events3.prototype.removeListener = function(event, fn, context, once) {\n          if (!this._events.has(event))\n            return this;\n          if (!fn) {\n            clearEvent(this, event);\n            return this;\n          }\n          var listeners = this._events.get(event);\n          if (listeners.fn) {\n            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n              clearEvent(this, event);\n            }\n          } else {\n            for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n              if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n                events.push(listeners[i]);\n              }\n            }\n            if (events.length)\n              this._events.set(event, events.length === 1 ? events[0] : events);\n            else\n              clearEvent(this, event);\n          }\n          return this;\n        };\n        Events3.prototype.removeAllListeners = function(event) {\n          if (event) {\n            if (this._events.delete(event))\n              clearEvent(this, event);\n          } else {\n            this._events = /* @__PURE__ */ new Map();\n            this._eventsCount = 0;\n          }\n          return this;\n        };\n        Object.defineProperty(Events3.prototype, \"off\", {\n          get: function() {\n            return this.removeListener;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Events3.prototype, \"addListener\", {\n          get: function() {\n            return this.on;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        return Events3;\n      }();\n      exports.Events = Events2;\n    }\n  });\n\n  // node_modules/@geckos.io/common/lib/bridge.js\n  var import_events = __toESM(require_cjs(), 1);\n  var Bridge = class {\n    constructor() {\n      this.eventEmitter = new import_events.Events();\n    }\n    emit(eventName, data, connection = {}) {\n      this.eventEmitter.emit(eventName, data, connection);\n    }\n    on(eventName, cb) {\n      return this.eventEmitter.on(eventName, (data, options) => {\n        cb(data, options);\n      });\n    }\n    removeAllListeners() {\n      this.eventEmitter.removeAllListeners();\n    }\n  };\n  var bridge = new Bridge();\n\n  // node_modules/@geckos.io/common/lib/constants.js\n  var EVENTS = {\n    CONNECT: \"connect\",\n    CONNECTION: \"connection\",\n    DATA_CHANNEL_IS_OPEN: \"dataChannelIsOpen\",\n    DISCONNECT: \"disconnect\",\n    DISCONNECTED: \"disconnected\",\n    DROP: \"dropped\",\n    ERROR: \"error\",\n    RAW_MESSAGE: \"rawMessage\",\n    RECEIVED_FROM_DATA_CHANNEL: \"receiveFromDataChannel\",\n    SEND_OVER_DATA_CHANNEL: \"sendOverDataChannel\"\n  };\n  var ERRORS = {\n    BROWSER_NOT_SUPPORTED: \"BROWSER_NOT_SUPPORTED\",\n    COULD_NOT_PARSE_MESSAGE: \"COULD_NOT_PARSE_MESSAGE\",\n    DROPPED_FROM_BUFFERING: \"DROPPED_FROM_BUFFERING\",\n    MAX_MESSAGE_SIZE_EXCEEDED: \"MAX_MESSAGE_SIZE_EXCEEDED\"\n  };\n\n  // node_modules/@geckos.io/common/lib/types.js\n  var ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n\n  // node_modules/@geckos.io/common/lib/helpers.js\n  var tick = typeof Promise == \"function\" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout;\n  var isStringMessage = (data) => {\n    return typeof data === \"string\";\n  };\n  var isBufferMessage = (data) => {\n    return data instanceof ArrayBuffer || data instanceof ArrayBufferView;\n  };\n  var isJSONMessage = (data) => {\n    try {\n      if (typeof data !== \"string\")\n        return false;\n      if (!isNaN(parseInt(data)))\n        return false;\n      JSON.parse(data);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  };\n\n  // node_modules/@geckos.io/common/lib/parseMessage.js\n  var ParseMessage = (ev) => {\n    let { data } = ev;\n    if (!data)\n      data = ev;\n    const isBuffer = isBufferMessage(data);\n    const isJson = isJSONMessage(data);\n    const isString = isStringMessage(data);\n    if (isJson) {\n      const object = JSON.parse(data);\n      const key = Object.keys(object)[0];\n      const value = object[key];\n      return { key, data: value };\n    }\n    if (isBuffer) {\n      return { key: EVENTS.RAW_MESSAGE, data };\n    }\n    if (isString) {\n      return { key: EVENTS.RAW_MESSAGE, data };\n    }\n    return { key: \"error\", data: new Error(ERRORS.COULD_NOT_PARSE_MESSAGE) };\n  };\n  var parseMessage_default = ParseMessage;\n\n  // node_modules/@geckos.io/common/lib/sendMessage.js\n  var SendMessage = (dataChannel, maxMessageSize, eventName, data = null) => {\n    var _a;\n    const send = (data2, isBuffer) => {\n      var _a2;\n      const bytes = (_a2 = data2.byteLength) !== null && _a2 !== void 0 ? _a2 : data2.length * 2;\n      if (typeof maxMessageSize === \"number\" && bytes > maxMessageSize) {\n        throw new Error(`maxMessageSize of ${maxMessageSize} exceeded`);\n      } else {\n        Promise.resolve().then(() => {\n          if (dataChannel.send)\n            dataChannel.send(data2);\n          else {\n            if (!isBuffer)\n              dataChannel.sendMessage(data2);\n            else\n              dataChannel.sendMessageBinary(Buffer.from(data2));\n          }\n        }).catch((error) => {\n          console.log(\"error\", error);\n        });\n      }\n    };\n    if (!dataChannel)\n      return;\n    if (dataChannel.readyState === \"open\" || ((_a = dataChannel.isOpen) === null || _a === void 0 ? void 0 : _a.call(dataChannel))) {\n      try {\n        if (eventName === EVENTS.RAW_MESSAGE && data !== null && (isStringMessage(data) || isBufferMessage(data))) {\n          send(data, isBufferMessage(data));\n        } else {\n          send(JSON.stringify({ [eventName]: data }), false);\n        }\n      } catch (error) {\n        console.error(\"Error in sendMessage.ts: \", error.message);\n        return error;\n      }\n    }\n  };\n  var sendMessage_default = SendMessage;\n\n  // node_modules/@geckos.io/client/lib/wrtc/connectionsManager.js\n  var ConnectionsManagerClient = class {\n    constructor(url, authorization, label, rtcConfiguration) {\n      this.url = url;\n      this.authorization = authorization;\n      this.label = label;\n      this.rtcConfiguration = rtcConfiguration;\n      this.bridge = new Bridge();\n      this.onDataChannel = (ev) => {\n        const { channel } = ev;\n        if (channel.label !== this.label)\n          return;\n        this.dataChannel = channel;\n        this.dataChannel.binaryType = \"arraybuffer\";\n        this.dataChannel.onmessage = (ev2) => {\n          const { key, data } = parseMessage_default(ev2);\n          this.bridge.emit(key, data);\n        };\n      };\n    }\n    emit(eventName, data = null) {\n      sendMessage_default(this.dataChannel, this.maxMessageSize, eventName, data);\n    }\n    async fetchAdditionalCandidates(host, id) {\n      var _a;\n      if (((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.readyState) === \"closed\")\n        return;\n      const res = await fetch(`${host}/connections/${id}/additional-candidates`, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (res.ok) {\n        const candidates = await res.json();\n        candidates.forEach((c) => {\n          this.localPeerConnection.addIceCandidate(c);\n        });\n      }\n    }\n    async connect() {\n      const host = `${this.url}/.wrtc/v2`;\n      let headers = { \"Content-Type\": \"application/json\" };\n      if (this.authorization)\n        headers = { ...headers, [\"Authorization\"]: this.authorization };\n      let userData = {};\n      try {\n        const res = await fetch(`${host}/connections`, {\n          method: \"POST\",\n          headers\n        });\n        if (res.status >= 300) {\n          throw {\n            name: \"Error\",\n            message: `Connection failed with status code ${res.status}.`,\n            status: res.status,\n            statusText: res.statusText\n          };\n        }\n        const json = await res.json();\n        userData = json.userData;\n        this.remotePeerConnection = json;\n      } catch (error) {\n        console.error(error.message);\n        return { error };\n      }\n      const { id, localDescription } = this.remotePeerConnection;\n      const configuration = {\n        sdpSemantics: \"unified-plan\",\n        ...this.rtcConfiguration\n      };\n      const RTCPc = RTCPeerConnection || webkitRTCPeerConnection;\n      this.localPeerConnection = new RTCPc(configuration);\n      const showBackOffIntervals = (attempts = 10, initial = 50, factor = 1.8, jitter = 20) => Array(attempts).fill(0).map((_, index) => parseInt((initial * factor ** index).toString()) + parseInt((Math.random() * jitter).toString()));\n      showBackOffIntervals().forEach((ms) => {\n        setTimeout(() => {\n          this.fetchAdditionalCandidates(host, id).catch(() => {\n          });\n        }, ms);\n      });\n      try {\n        await this.localPeerConnection.setRemoteDescription(localDescription);\n        this.localPeerConnection.addEventListener(\"datachannel\", this.onDataChannel, { once: true });\n        const originalAnswer = await this.localPeerConnection.createAnswer();\n        const updatedAnswer = new RTCSessionDescription({\n          type: \"answer\",\n          sdp: originalAnswer.sdp\n        });\n        await this.localPeerConnection.setLocalDescription(updatedAnswer);\n        try {\n          await fetch(`${host}/connections/${id}/remote-description`, {\n            method: \"POST\",\n            body: JSON.stringify(this.localPeerConnection.localDescription),\n            headers: {\n              \"Content-Type\": \"application/json\"\n            }\n          });\n        } catch (error) {\n          console.error(error.message);\n          return { error };\n        }\n        const waitForDataChannel = () => {\n          return new Promise((resolve) => {\n            this.localPeerConnection.addEventListener(\"datachannel\", () => {\n              resolve();\n            }, { once: true });\n          });\n        };\n        if (!this.dataChannel)\n          await waitForDataChannel();\n        return {\n          userData,\n          localPeerConnection: this.localPeerConnection,\n          dataChannel: this.dataChannel,\n          id\n        };\n      } catch (error) {\n        console.error(error.message);\n        this.localPeerConnection.close();\n        return { error };\n      }\n    }\n  };\n\n  // node_modules/@geckos.io/client/lib/wrtc/peerConnection.js\n  var PeerConnection = class {\n    async connect(connectionsManager) {\n      const webRTCPcSupported = RTCPeerConnection || webkitRTCPeerConnection;\n      if (webRTCPcSupported) {\n        const { localPeerConnection, dataChannel, id, userData, error } = await connectionsManager.connect();\n        if (error)\n          return { error };\n        if (!localPeerConnection || !dataChannel || !id || !userData)\n          return { error: new Error('Something went wrong in \"await connectionsManager.connect()\"') };\n        this.localPeerConnection = localPeerConnection;\n        this.dataChannel = dataChannel;\n        this.id = id;\n        return { userData };\n      } else {\n        const error = new Error(ERRORS.BROWSER_NOT_SUPPORTED);\n        console.error(error.message);\n        return { error };\n      }\n    }\n  };\n\n  // node_modules/@geckos.io/common/lib/makeRandomId.js\n  var makeRandomId = (length = 24) => {\n    const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    let id = \"\";\n    for (let i = 0; i < length; i++) {\n      id += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return id;\n  };\n  var makeRandomId_default = makeRandomId;\n\n  // node_modules/@geckos.io/common/lib/runInterval.js\n  var runInterval = (interval = 200, runs = 1, cb) => {\n    let counter = 0;\n    if (typeof cb !== \"function\") {\n      console.error(\"You have to define your callback function!\");\n      return;\n    }\n    const i = setInterval(() => {\n      cb();\n      counter++;\n      if (counter === runs - 1) {\n        clearInterval(i);\n      }\n    }, interval);\n    cb();\n  };\n  var runInterval_default = runInterval;\n\n  // node_modules/@geckos.io/common/lib/reliableMessage.js\n  var makeReliable = (options, cb) => {\n    const { interval = 150, runs = 10 } = options;\n    const id = makeRandomId_default(24);\n    runInterval_default(interval, runs, () => {\n      cb(id);\n    });\n  };\n\n  // node_modules/@geckos.io/client/lib/geckos/channel.js\n  var ClientChannel = class {\n    constructor(url, authorization, port, label, rtcConfiguration) {\n      this.userData = {};\n      this.receivedReliableMessages = [];\n      this.url = port ? `${url}:${port}` : url;\n      this.connectionsManager = new ConnectionsManagerClient(this.url, authorization, label, rtcConfiguration);\n      this.bridge = this.connectionsManager.bridge;\n      this.bridge.on(EVENTS.DISCONNECTED, () => this.bridge.removeAllListeners());\n    }\n    onconnectionstatechange() {\n      const lpc = this.peerConnection.localPeerConnection;\n      lpc.onconnectionstatechange = () => {\n        if (lpc.connectionState === \"disconnected\" || lpc.connectionState === \"closed\")\n          this.bridge.emit(EVENTS.DISCONNECTED);\n      };\n    }\n    get id() {\n      return this.peerConnection.id;\n    }\n    close() {\n      this.peerConnection.localPeerConnection.close();\n      this.bridge.emit(EVENTS.DISCONNECTED);\n      try {\n        const host = `${this.url}/.wrtc/v2`;\n        fetch(`${host}/connections/${this.id}/close`, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          }\n        });\n      } catch (error) {\n        console.error(error.message);\n      }\n    }\n    emit(eventName, data = null, options) {\n      if (options && options.reliable) {\n        makeReliable(options, (id) => this.connectionsManager.emit(eventName, {\n          MESSAGE: data,\n          RELIABLE: 1,\n          ID: id\n        }));\n      } else {\n        this.connectionsManager.emit(eventName, data);\n      }\n    }\n    get raw() {\n      return {\n        emit: (rawMessage) => this.emit(EVENTS.RAW_MESSAGE, rawMessage)\n      };\n    }\n    onRaw(callback) {\n      this.bridge.on(EVENTS.RAW_MESSAGE, (rawMessage) => {\n        const cb = (rawMessage2) => callback(rawMessage2);\n        cb(rawMessage);\n      });\n    }\n    async onConnect(callback) {\n      var _a;\n      this.peerConnection = new PeerConnection();\n      const response = await this.peerConnection.connect(this.connectionsManager);\n      if (response.error)\n        callback(response.error);\n      else {\n        if (response.userData)\n          this.userData = response.userData;\n        this.maxMessageSize = this.connectionsManager.maxMessageSize = (_a = this.peerConnection.localPeerConnection.sctp) === null || _a === void 0 ? void 0 : _a.maxMessageSize;\n        this.onconnectionstatechange();\n        callback();\n      }\n    }\n    onDisconnect(callback) {\n      this.bridge.on(EVENTS.DISCONNECTED, callback);\n    }\n    on(eventName, callback) {\n      this.bridge.on(eventName, (data) => {\n        const isReliableMessage = data && data.RELIABLE === 1 && data.ID !== \"undefined\";\n        const expireTime = 15e3;\n        const deleteExpiredReliableMessages = () => {\n          const currentTime = new Date().getTime();\n          this.receivedReliableMessages.forEach((msg, index, object) => {\n            if (msg.expire <= currentTime) {\n              object.splice(index, 1);\n            }\n          });\n        };\n        if (isReliableMessage) {\n          deleteExpiredReliableMessages();\n          if (this.receivedReliableMessages.filter((obj) => obj.id === data.ID).length === 0) {\n            this.receivedReliableMessages.push({\n              id: data.ID,\n              timestamp: new Date(),\n              expire: new Date().getTime() + expireTime\n            });\n            callback(data.MESSAGE);\n          } else {\n          }\n        } else {\n          callback(data);\n        }\n      });\n    }\n  };\n  var geckosClient = (options = {}) => {\n    const { authorization = void 0, iceServers = [], iceTransportPolicy = \"all\", label = \"geckos.io\", port = 9208, url = `${location.protocol}//${location.hostname}` } = options;\n    return new ClientChannel(url, authorization, port, label, { iceServers, iceTransportPolicy });\n  };\n  var channel_default = geckosClient;\n\n  // code/adapters/geckos-client.ts\n  var logger = new gdjs.Logger(\"THNK - Geckos.io Adapter\");\n  THNK.GeckosClientAdapter = class GeckosClientAdapter extends THNK.ClientAdapter {\n    ip;\n    port;\n    connection = null;\n    constructor(ip, port) {\n      super();\n      this.ip = `http://${ip}`;\n      this.port = port;\n    }\n    async prepare() {\n      this.connection = channel_default({ url: this.ip, port: this.port, label: \"THNK\" });\n      await new Promise(\n        (resolve, reject) => this.connection.onConnect((error) => {\n          if (error)\n            return reject(error.message);\n          this.connection.onRaw(\n            (message) => this.onMessage(message)\n          );\n          this.connection.onDisconnect(() => this.onDisconnection());\n          resolve();\n        })\n      );\n    }\n    close() {\n      if (this.connection)\n        this.connection.close();\n    }\n    doSendMessage(message) {\n      if (!this.connection) {\n        return logger.error(\n          \"Tried to send a message on an unestablished connection!\"\n        );\n      }\n      this.connection.raw.emit(\n        message.buffer.slice(message.buffer.byteLength - message.byteLength)\n      );\n    }\n    getServerIP() {\n      return this.ip;\n    }\n    getServerPort() {\n      return this.port;\n    }\n  };\n})();\n/**\n * @package      npmjs.com/package/@yandeu/events (events.min.js)\n *\n * @author       Arnout Kazemier (https://github.com/3rd-Eden)\n * @copyright    Copyright (c) 2014 Arnout Kazemier\n * @license      {@link https://github.com/primus/eventemitter3/blob/master/LICENSE|MIT}\n *\n * @author       Yannick Deubel (https://github.com/yandeu)\n * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/yandeu/events\n * @license      {@link https://github.com/yandeu/events/blob/master/LICENSE|MIT}\n */\n",
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Connects to a geckos.io THNK server.",
      "fullName": "Connect to server",
      "functionType": "Action",
      "name": "ConnectToServer",
      "sentence": "Connect to server at _PARAM1_:_PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "THNK.client.startClient(",
            "    runtimeScene,",
            "    new THNK.GeckosClientAdapter(",
            "        eventsFunctionContext.getArgument(\"Host\"),",
            "        eventsFunctionContext.getArgument(\"Port\")",
            "    )",
            ");",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Hostname (URL or IP address)",
          "name": "Host",
          "type": "string"
        },
        {
          "description": "The port the server is hosted on",
          "name": "Port",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if the current scene is running with the Geckos Client adapter.",
      "fullName": "Geckos client adapter in use",
      "functionType": "Condition",
      "name": "IsGeckosClientInUse",
      "sentence": "Geckos client is running",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "eventsFunctionContext.returnValue = runtimeScene.thnkClient && runtimeScene.thnkClient.adapter instanceof THNK.GeckosClientAdapter;\r",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "the IP address the running geckos client listens to",
      "fullName": "IP address",
      "functionType": "ExpressionAndCondition",
      "name": "ServerIP",
      "sentence": "Geckos server IP address",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (runtimeScene.thnkClient && runtimeScene.thnkClient.adapter instanceof THNK.GeckosClientAdapter)\r",
            "    eventsFunctionContext.returnValue = runtimeScene.thnkClient.adapter.getServerIP()\r",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "the port of the server the running geckos client is connected to",
      "fullName": "Server Port",
      "functionType": "ExpressionAndCondition",
      "name": "ServerPort",
      "sentence": "Server port",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (runtimeScene.thnkClient && runtimeScene.thnkClient.adapter instanceof THNK.GeckosClientAdapter)\r",
            "    eventsFunctionContext.returnValue = runtimeScene.thnkClient.adapter.getServerPort()\r",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}